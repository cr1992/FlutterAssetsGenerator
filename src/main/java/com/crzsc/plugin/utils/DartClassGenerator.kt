package com.crzsc.plugin.utils

import com.crzsc.plugin.utils.PluginUtils.toLowCamelCase
import com.intellij.openapi.diagnostic.Logger

/**
 * Dart 代码生成器
 * 负责将资源树转换为 Dart 类结构
 */
class DartClassGenerator(
    private val rootNode: AssetNode,
    private val config: ModulePubSpecConfig,
    private val hasSvg: Boolean, // 项目中是否包含 SVG 文件且有相应依赖
    private val hasLottie: Boolean // 项目中是否包含 Lottie 文件且有相应依赖
) {
    companion object {
        private val LOG = Logger.getInstance(DartClassGenerator::class.java)
    }
    private val buffer = StringBuilder()
    // 用于收集额外的类（目录类），它们将被追加到主类之后
    private val directoryClasses = StringBuilder()

    fun generate(): String {
        LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [DartClassGenerator] Starting code generation...")
        buffer.append("///This file is automatically generated. DO NOT EDIT, all your changes would be lost.\n")
        val className = FileHelperNew.getGeneratedClassName(config)
        LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [DartClassGenerator] Root class name: $className")

        // 生成 Imports
        buffer.append("import 'package:flutter/widgets.dart';\n")
        if (hasSvg) {
            buffer.append("import 'package:flutter_svg/flutter_svg.dart';\n")
        }
        if (hasLottie) {
            buffer.append("import 'package:lottie/lottie.dart';\n")
            buffer.append("import 'package:lottie/src/lottie_builder.dart';\n")
            buffer.append("import 'package:lottie/src/composition.dart';\n")
        }
        buffer.append("\n")

        // 生成主类 (Root Class)
        val rootClassName = className
        buffer.append("class $rootClassName {\n")
        buffer.append("  $rootClassName._();\n\n")

        val prefix = config.getLeadingWithPackageNameIfChecked()
        basePrefix = prefix // 存储基础前缀供递归使用
        LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [DartClassGenerator] Base prefix: '$prefix'")
        LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [DartClassGenerator] Root node children count: ${rootNode.children.size}")
        
        // 生成根节点下的字段
        LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [DartClassGenerator] Generating root class fields...")
        generateNodeFields(rootNode, prefix, isRoot = true)

        buffer.append("}\n\n")

        // 生成所有目录类
        LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [DartClassGenerator] Generating directory classes...")
        generateAllDirectoryClasses(rootNode)

        // 追加生成的目录类
        buffer.append(directoryClasses)

        // 生成辅助类 (AssetGenImage 等)
        generateHelperClasses()

        return buffer.toString()
    }

    /**
     * 生成节点下的字段列表
     * @param node 当前资源节点
     * @param prefix 资源路径前缀（通常包含包名或其他路径信息）
     * @param isRoot 是否为根类
     */
    private fun generateNodeFields(node: AssetNode, prefix: String, isRoot: Boolean) {
        LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [generateNodeFields] Processing node: ${node.name}, path: ${node.path}, isRoot: $isRoot")
        // 如果是根节点且需要扁平化,则处理扁平化后的子节点
        val shouldFlatten = isRoot && shouldFlattenRoot(node)
        LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [generateNodeFields] Should flatten: $shouldFlatten")
        val nodesToProcess = if (shouldFlatten) {
            LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [generateNodeFields] Flattening - processing children of: ${node.children[0].name}")
            node.children[0].children
        } else {
            node.children
        }
        LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [generateNodeFields] Nodes to process: ${nodesToProcess.size}")
        
        // 将目录排在前面,文件排在后面,并按名称排序
        val sortedChildren = nodesToProcess.sortedWith(compareBy({ it.type == MediaType.DIRECTORY }, { it.name }))

        // 检测重名并生成唯一名称映射
        val nameMap = mutableMapOf<AssetNode, String>()
        val usedNames = mutableSetOf<String>()
        
        LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [generateNodeFields] Processing ${sortedChildren.size} children")
        
        // 第一步:检查是否有同名但不同扩展名的文件
        val baseNameCount = mutableMapOf<String, MutableList<AssetNode>>()
        for (child in sortedChildren) {
            if (child.type != MediaType.DIRECTORY) {
                val baseName = getSafeName(child.name)
                baseNameCount.getOrPut(baseName) { mutableListOf() }.add(child)
            }
        }
        
        // 记录检测到的重名文件
        baseNameCount.filter { it.value.size > 1 }.forEach { (baseName, files) ->
            LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [generateNodeFields] Detected ${files.size} files with same basename: $baseName")
            files.forEach { file ->
                LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [generateNodeFields]   - ${file.name} (ext: ${file.virtualFile?.extension})")
            }
        }
        
        // 第二步:生成唯一名称
        for (child in sortedChildren) {
            val baseName = getSafeName(child.name)
            var uniqueName = baseName
            
            // 如果是文件且存在同名文件(不同扩展名),添加扩展名(驼峰式)
            if (child.type != MediaType.DIRECTORY) {
                val sameBaseNameFiles = baseNameCount[baseName] ?: emptyList()
                if (sameBaseNameFiles.size > 1) {
                    // 有多个同名文件,添加扩展名(驼峰式)
                    val ext = child.virtualFile?.extension?.let { getSafeName(it) } ?: ""
                    if (ext.isNotEmpty()) {
                        // 将扩展名首字母大写,形成驼峰式
                        val extCamelCase = ext.replaceFirstChar { it.uppercase() }
                        uniqueName = "${baseName}${extCamelCase}"
                        LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [generateNodeFields] Renaming ${child.name}: $baseName → $uniqueName")
                    }
                }
            }
            
            // 如果名称仍然冲突,添加数字后缀
            var finalName = uniqueName
            var counter = 1
            while (usedNames.contains(finalName)) {
                finalName = "${uniqueName}${counter}"
                counter++
                LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [generateNodeFields] Name conflict detected, using: $finalName")
            }
            
            nameMap[child] = finalName
            usedNames.add(finalName)
        }

        // 生成字段
        for (child in sortedChildren) {
            val fieldName = nameMap[child]!!
            LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [generateNodeFields] Generating field: $fieldName for ${child.name} (type: ${child.type})")
            
            if (child.type == MediaType.DIRECTORY) {
                val dirClassName = getGenClassName(child)
                LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [generateNodeFields] Directory class name: $dirClassName")
                
                // 生成目录字段引用
                // 根类使用 static const,子目录类使用 final
                // 例如: static const $AssetsIconsGen icons = $AssetsIconsGen();
                buffer.append("  ${if (isRoot) "static const" else "final"} $dirClassName $fieldName = ${if (isRoot) "" else "const "}$dirClassName();\n")
                
                // 目录类的生成在 generate() 方法中统一处理
            } else {
                // child.path 已经包含完整的相对路径,加上包名前缀即可
                val fullPath = "$prefix${child.path}"
                
                // 根据文件类型生成不同类型的字段
                // 根类使用 static const,子目录类使用 final
                when (child.type) {
                    MediaType.IMAGE -> {
                        buffer.append("  ${if (isRoot) "static const" else "final"} AssetGenImage $fieldName = ${if (isRoot) "" else "const "}AssetGenImage('$fullPath');\n")
                    }
                    MediaType.SVG -> {
                        buffer.append("  ${if (isRoot) "static const" else "final"} SvgGenImage $fieldName = ${if (isRoot) "" else "const "}SvgGenImage('$fullPath');\n")
                    }
                    MediaType.LOTTIE -> {
                        buffer.append("  ${if (isRoot) "static const" else "final"} LottieGenImage $fieldName = ${if (isRoot) "" else "const "}LottieGenImage('$fullPath');\n")
                    }
                    else -> {
                        buffer.append("  ${if (isRoot) "static const" else "final"} String $fieldName = ${if (isRoot) "" else "const "}'$fullPath';\n")
                    }
                }
            }
        }
    }

    /**
     * 递归生成所有目录类
     * 策略:一级目录不生成类,直接将其子目录作为根类的字段
     * 只有二级及以下目录才生成独立的类
     */
    private fun generateAllDirectoryClasses(node: AssetNode) {
        LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [generateAllDirectoryClasses] Starting...")
        // 获取需要处理的节点
        val shouldFlatten = shouldFlattenRoot(node)
        LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [generateAllDirectoryClasses] Should flatten: $shouldFlatten")
        val nodesToProcess = if (shouldFlatten) {
            // 如果根节点只有一个目录子节点(通常是 "assets"),跳过它,处理其子节点
            LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [generateAllDirectoryClasses] Flattening - skipping ${node.children[0].name}")
            node.children[0].children
        } else {
            node.children
        }
        LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [generateAllDirectoryClasses] Processing ${nodesToProcess.size} top-level nodes")
        
        // 递归收集所有需要生成类的目录节点
        val allDirectories = mutableListOf<AssetNode>()
        fun collectDirectories(nodes: List<AssetNode>, depth: Int = 0) {
            val indent = "  ".repeat(depth)
            for (child in nodes) {
                LOG.info("$indent[collectDirectories] Checking: ${child.name} (type: ${child.type})")
                if (child.type == MediaType.DIRECTORY) {
                    LOG.info("$indent[collectDirectories] Adding directory: ${child.name}, path: ${child.path}")
                    allDirectories.add(child)
                    // 递归收集子目录
                    collectDirectories(child.children, depth + 1)
                }
            }
        }
        
        collectDirectories(nodesToProcess)
        
        LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [generateAllDirectoryClasses] Collected ${allDirectories.size} directories to generate")
        allDirectories.forEachIndexed { index, dir ->
            LOG.info("  [$index] ${dir.name} (path: ${dir.path})")
        }
        
        // 为所有收集到的目录生成类
        for (dir in allDirectories) {
            generateDirectoryClass(dir, basePrefix)
        }
        LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [generateAllDirectoryClasses] Completed")
    }
    
    /**
     * 判断是否应该扁平化根节点
     * 当根节点只有一个目录子节点时,应该扁平化
     */
    private fun shouldFlattenRoot(node: AssetNode): Boolean {
        return node.children.size == 1 && node.children[0].type == MediaType.DIRECTORY
    }

    // 存储基础包名前缀,用于所有目录类
    private var basePrefix: String = ""
    
    /**
     * 生成目录对应的类
     * 注意:此方法只生成当前目录的类,不递归生成子目录类
     * 子目录类由 generateAllDirectoryClasses 统一管理
     */
    private fun generateDirectoryClass(node: AssetNode, prefix: String) {
        val className = getGenClassName(node)
        LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [generateDirectoryClass] Generating class: $className for node: ${node.name} (path: ${node.path})")
        
        // 将生成的代码追加到 directoryClasses 缓冲区
        directoryClasses.append("class $className {\n")
        directoryClasses.append("  const $className();\n\n")
        
        // 生成该目录类下的字段
        LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [generateDirectoryClass] Generating fields for $className...")
        generateDirectoryFields(node, prefix, directoryClasses)
        
        directoryClasses.append("}\n\n")
        LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [generateDirectoryClass] Completed $className")
    }

    /**
     * 生成目录类内部的字段
     * 逻辑与 generateNodeFields 类似，但输出到指定的 StringBuilder，且字段非 static
     */
    private fun generateDirectoryFields(node: AssetNode, prefix: String, sb: StringBuilder) {
        val sortedChildren = node.children.sortedWith(compareBy({ it.type != MediaType.DIRECTORY }, { it.name }))

        // 检测重名并生成唯一名称映射
        val nameMap = mutableMapOf<AssetNode, String>()
        val usedNames = mutableSetOf<String>()
        
        LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [generateDirectoryFields] Processing ${sortedChildren.size} children for node: ${node.name}")
        
        // 第一步:检查是否有同名但不同扩展名的文件
        val baseNameCount = mutableMapOf<String, MutableList<AssetNode>>()
        for (child in sortedChildren) {
            if (child.type != MediaType.DIRECTORY) {
                val baseName = getSafeName(child.name)
                baseNameCount.getOrPut(baseName) { mutableListOf() }.add(child)
            }
        }
        
        // 记录检测到的重名文件
        baseNameCount.filter { it.value.size > 1 }.forEach { (baseName, files) ->
            LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [generateDirectoryFields] Detected ${files.size} files with same basename: $baseName")
            files.forEach { file ->
                LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [generateDirectoryFields]   - ${file.name} (ext: ${file.virtualFile?.extension})")
            }
        }
        
        // 第二步:生成唯一名称
        for (child in sortedChildren) {
            val baseName = getSafeName(child.name)
            var uniqueName = baseName
            
            // 如果是文件且存在同名文件(不同扩展名),添加扩展名(驼峰式)
            if (child.type != MediaType.DIRECTORY) {
                val sameBaseNameFiles = baseNameCount[baseName] ?: emptyList()
                if (sameBaseNameFiles.size > 1) {
                    // 有多个同名文件,添加扩展名(驼峰式)
                    val ext = child.virtualFile?.extension?.let { getSafeName(it) } ?: ""
                    if (ext.isNotEmpty()) {
                        // 将扩展名首字母大写,形成驼峰式
                        val extCamelCase = ext.replaceFirstChar { it.uppercase() }
                        uniqueName = "${baseName}${extCamelCase}"
                        LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [generateDirectoryFields] Renaming ${child.name}: $baseName → $uniqueName")
                    }
                }
            }
            
            // 如果名称仍然冲突,添加数字后缀
            var finalName = uniqueName
            var counter = 1
            while (usedNames.contains(finalName)) {
                finalName = "${uniqueName}${counter}"
                counter++
                LOG.info("[FlutterAssetsGenerator #DartClassGenerator] [generateDirectoryFields] Name conflict detected, using: $finalName")
            }
            
            nameMap[child] = finalName
            usedNames.add(finalName)
        }

        for (child in sortedChildren) {
            val fieldName = nameMap[child]!!
            
            if (child.type == MediaType.DIRECTORY) {
                val dirClassName = getGenClassName(child)

                // 目录类型字段,使用 final
                sb.append("  final $dirClassName $fieldName = const $dirClassName();\n")
                
                // 子目录类的生成已在 generateDirectoryClass 中递归处理
            } else {
                // child.path 已经包含完整的相对路径,加上包名前缀即可
                val fullPath = "$prefix${child.path}"

                // 文件类型字段,使用 final
                when (child.type) {
                    MediaType.IMAGE -> {
                        sb.append("  final AssetGenImage $fieldName = const AssetGenImage('$fullPath');\n")
                    }
                    MediaType.SVG -> {
                        sb.append("  final SvgGenImage $fieldName = const SvgGenImage('$fullPath');\n")
                    }
                    MediaType.LOTTIE -> {
                        sb.append("  final LottieGenImage $fieldName = const LottieGenImage('$fullPath');\n")
                    }
                    else -> {
                        sb.append("  final String $fieldName = const '$fullPath';\n")
                    }
                }
            }
        }
    }


    /**
     * 生成辅助类 (AssetGenImage, SvgGenImage, LottieGenImage)
     * 这些辅助类封装了路径并提供了直接获取 Widget 的方法
     */
    private fun generateHelperClasses() {
        // AssetGenImage: 封装普通图片资源，提供 .image() 和 .provider() 方法
        buffer.append("""
class AssetGenImage {
  const AssetGenImage(this._assetName, {this.size, this.flavors = const {}});

  final String _assetName;

  final Size? size;
  final Set<String> flavors;

  Image image({
    Key? key,
    AssetBundle? bundle,
    ImageFrameBuilder? frameBuilder,
    ImageErrorWidgetBuilder? errorBuilder,
    String? semanticLabel,
    bool excludeFromSemantics = false,
    double? scale,
    double? width,
    double? height,
    Color? color,
    Animation<double>? opacity,
    BlendMode? colorBlendMode,
    BoxFit? fit,
    AlignmentGeometry alignment = Alignment.center,
    ImageRepeat repeat = ImageRepeat.noRepeat,
    Rect? centerSlice,
    bool matchTextDirection = false,
    bool gaplessPlayback = false,
    bool isAntiAlias = false,
    String? package,
    FilterQuality filterQuality = FilterQuality.low,
    int? cacheWidth,
    int? cacheHeight,
  }) {
    return Image.asset(
      _assetName,
      key: key,
      bundle: bundle,
      frameBuilder: frameBuilder,
      errorBuilder: errorBuilder,
      semanticLabel: semanticLabel,
      excludeFromSemantics: excludeFromSemantics,
      scale: scale,
      width: width,
      height: height,
      color: color,
      opacity: opacity,
      colorBlendMode: colorBlendMode,
      fit: fit,
      alignment: alignment,
      repeat: repeat,
      centerSlice: centerSlice,
      matchTextDirection: matchTextDirection,
      gaplessPlayback: gaplessPlayback,
      isAntiAlias: isAntiAlias,
      package: package,
      filterQuality: filterQuality,
      cacheWidth: cacheWidth,
      cacheHeight: cacheHeight,
    );
  }

  ImageProvider provider({
    AssetBundle? bundle,
    String? package,
  }) {
    return AssetImage(
      _assetName,
      bundle: bundle,
      package: package,
    );
  }

  Widget custom({
    Key? key,
    required Widget Function(BuildContext context, String assetPath) builder,
  }) {
    return Builder(
      key: key,
      builder: (context) => builder(context, _assetName),
    );
  }
  
  String get path => _assetName;

  String get keyName => _assetName;
}
""".trimIndent())
        buffer.append("\n\n")

        // SvgGenImage
        buffer.append("""
class SvgGenImage {
  const SvgGenImage(this._assetName);

  final String _assetName;

""".trimIndent())

        if (hasSvg) {
            buffer.append("""
  SvgPicture svg({
    Key? key,
    bool matchTextDirection = false,
    AssetBundle? bundle,
    String? package,
    double? width,
    double? height,
    BoxFit fit = BoxFit.contain,
    AlignmentGeometry alignment = Alignment.center,
    bool allowDrawingOutsideViewBox = false,
    WidgetBuilder? placeholderBuilder,
    String? semanticsLabel,
    bool excludeFromSemantics = false,
    SvgTheme? theme,
    Clip clipBehavior = Clip.hardEdge,
    @deprecated Color? color,
    @deprecated BlendMode colorBlendMode = BlendMode.srcIn,
    @deprecated bool cacheColorFilter = false,
  }) {
    return SvgPicture.asset(
      _assetName,
      key: key,
      matchTextDirection: matchTextDirection,
      bundle: bundle,
      package: package,
      width: width,
      height: height,
      fit: fit,
      alignment: alignment,
      allowDrawingOutsideViewBox: allowDrawingOutsideViewBox,
      placeholderBuilder: placeholderBuilder,
      semanticsLabel: semanticsLabel,
      excludeFromSemantics: excludeFromSemantics,
      theme: theme,
      color: color,
      colorBlendMode: colorBlendMode,
      clipBehavior: clipBehavior,
      cacheColorFilter: cacheColorFilter,
    );
  }
""".trimIndent())
        }

        buffer.append("""

  Widget custom({
    Key? key,
    required Widget Function(BuildContext context, String assetPath) builder,
  }) {
    return Builder(
      key: key,
      builder: (context) => builder(context, _assetName),
    );
  }

  String get path => _assetName;

  String get keyName => _assetName;
}
""".trimIndent())
        buffer.append("\n\n")

        // LottieGenImage
        buffer.append("""
class LottieGenImage {
  const LottieGenImage(this._assetName);

  final String _assetName;

""".trimIndent())

        if (hasLottie) {
            buffer.append("""
  LottieBuilder lottie({
    Animation<double>? controller,
    bool? animate,
    FrameRate? frameRate,
    bool? repeat,
    bool? reverse,
    LottieDelegates? delegates,
    LottieOptions? options,
    void Function(LottieComposition)? onLoaded,
    LottieImageProviderFactory? imageProviderFactory,
    Key? key,
    AssetBundle? bundle,
    LottieFrameBuilder? frameBuilder,
    ImageErrorWidgetBuilder? errorBuilder,
    double? width,
    double? height,
    BoxFit? fit,
    AlignmentGeometry? alignment,
    String? package,
    bool? addRepaintBoundary,
    FilterQuality? filterQuality,
    WarningCallback? onWarning,
  }) {
    return Lottie.asset(
      _assetName,
      controller: controller,
      animate: animate,
      frameRate: frameRate,
      repeat: repeat,
      reverse: reverse,
      delegates: delegates,
      options: options,
      onLoaded: onLoaded,
      imageProviderFactory: imageProviderFactory,
      key: key,
      bundle: bundle,
      frameBuilder: frameBuilder,
      errorBuilder: errorBuilder,
      width: width,
      height: height,
      fit: fit,
      alignment: alignment,
      package: package,
      addRepaintBoundary: addRepaintBoundary,
      filterQuality: filterQuality,
      onWarning: onWarning,
    );
  }
""".trimIndent())
        }

        buffer.append("""
  Widget custom({
    Key? key,
    required Widget Function(BuildContext context, String assetPath) builder,
  }) {
    return Builder(
      key: key,
      builder: (context) => builder(context, _assetName),
    );
  }

  String get path => _assetName;

  String get keyName => _assetName;
}
""".trimIndent())
    }

    // 生成安全的变量名 (驼峰命名,处理关键词冲突和特殊字符)
    private fun getSafeName(name: String): String {
        // 移除文件扩展名
        val nameWithoutExt = name.substringBeforeLast('.')
        
        // 过滤特殊字符:空格、括号、引号等,替换为下划线
        val filtered = nameWithoutExt
            .replace(Regex("[\\s()\\[\\]{}'\"`!@#$%^&*+=|\\\\:;,<>?/]"), "_")
            .replace(Regex("_+"), "_") // 将连续的下划线替换为单个
            .trim('_') // 移除首尾的下划线
        
        // 转换为驼峰命名
        var newName = filtered.toLowCamelCase(Regex("[-_.]"))
        
        // 处理关键词冲突
        if (isKeyWord(newName)) {
            newName = "${newName}_"
        }
        
        return newName
    }

    /**
     * 生成目录对应的类名
     * 策略: 使用节点名称转换为驼峰命名 + "Gen" 后缀,并在前面加上 "$" 符号和根类名
     * 例如: image 目录 -> $AssetsImageGen
     */
    private fun getGenClassName(node: AssetNode): String {
        // 使用节点名称而不是完整路径
        val nodeName = node.name
        val safeName = nodeName.replace("-", "_").replace(".", "_")
        val camelCaseName = safeName.split("_")
            .joinToString("") { it.replaceFirstChar { c -> c.uppercase() } }
        return "$" + FileHelperNew.getGeneratedClassName(config) + camelCaseName + "Gen"
    }

    private fun isKeyWord(name: String): Boolean {
        return name in setOf(
            "abstract", "dynamic", "implements", "show", "as", "else", "import", "static", "assert", "enum", "in", "super",
            "async", "export", "interface", "switch", "await", "extends", "is", "sync", "break", "external", "library", "this",
            "case", "factory", "mixin", "throw", "catch", "false", "new", "true", "class", "final", "null", "try",
            "const", "finally", "on", "typedef", "continue", "for", "operator", "var", "covariant", "Function", "part", "void",
            "default", "get", "rethrow", "while", "deferred", "hide", "return", "with", "do", "if", "set", "yield"
        )
    }
}
